<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Learn on Zig Programming Language</title><link>//ziglang.github.io/www.ziglang.org/learn/</link><description>Recent content in Learn on Zig Programming Language</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="//ziglang.github.io/www.ziglang.org/learn/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting started on Linux</title><link>//ziglang.github.io/www.ziglang.org/learn/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/getting-started/</guid><description>linux</description></item><item><title>In-depth Overview</title><link>//ziglang.github.io/www.ziglang.org/learn/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/overview/</guid><description>Feature Highlights Small, simple language Focus on debugging your application rather than debugging your programming language knowledge.
Zig&amp;rsquo;s entire syntax is specified with a 500-line PEG grammar file.
There is no hidden control flow, no hidden memory allocations, no preprocessor, and no macros. If Zig code doesn&amp;rsquo;t look like it&amp;rsquo;s jumping away to call a function, then it isn&amp;rsquo;t. This means you can be sure that the following code calls only foo() and then bar(), and this is guaranteed without needing to know the types of anything:</description></item><item><title>Why Zig When There is Already C++, D, and Rust?</title><link>//ziglang.github.io/www.ziglang.org/learn/why_zig_rust_d_cpp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/why_zig_rust_d_cpp/</guid><description>No hidden control flow If Zig code doesn&amp;rsquo;t look like it&amp;rsquo;s jumping away to call a function, then it isn&amp;rsquo;t. This means you can be sure that the following code calls only foo() and then bar(), and this is guaranteed without needing to know the types of anything:
var a = b + c.d; foo(); bar(); D has @property functions, which are methods that you call with what looks like field access, so in the above example, c.</description></item></channel></rss>